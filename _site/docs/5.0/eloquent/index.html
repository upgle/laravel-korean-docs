<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Eloquent ORM</title>
  <meta name="description" content="라라벨 한글 메뉴얼에 대한 메뉴얼 페이지입니다.">

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
  <script src="/laravel-korean-docs/js/prism.js"></script>

  <link rel="stylesheet" href="/laravel-korean-docs/css/layout.css">
  <link rel="canonical" href="http://www.xpressengine.com/laravel-korean-docs/docs/5.0/eloquent/">
</head>


  <body>

    <div class="container">
    <header>
        <div class="wrap">
            <h1 class="logo">Laravel korean docs <small>laravel 한글 매뉴얼</small></h1>
            <div class="btn_area">
                <a class="button" href="https://github.com/xpressengine/laravel-korean-docs/tree/kr-5.0/kr">View on Github</a>
                <a class="button" href="https://github.com/xpressengine/laravel-korean-docs/archive/kr-5.0.zip">Download.zip</a>
                <a class="button" href="https://github.com/xpressengine/laravel-korean-docs.git">Git Repository</a>
            </div>
        </div>
    </header>
    <div class="supported">
        <div class="wrap">
            <a class="bnr" href="http://www.xpressengine.com"><img src="/laravel-korean-docs/img/bnr1.png" /></a><a class="bnr" href="http://dev.naver.com/d2"><img src="/laravel-korean-docs/img/bnr2.png" /></a><a class="bnr" href="http://xpressengine.github.io/XEIcon/"><img src="/laravel-korean-docs/img/bnr3.png" /></a><a class="bnr" href="http://xpressengine.github.io/Composer-korean-docs/"><img src="/laravel-korean-docs/img/bnr4.png" /></a><a class="bnr" href="http://laravel.com/"><img src="/laravel-korean-docs/img/bnr5.png" /></a>
        </div>
    </div>
    <div class="body docs">
        <div class="wrap">
            <section class="sidebar">
            <ul>
    <li>Prologue
        <ul>
            <li><a href="/laravel-korean-docs/docs/5.0/upgrade">업그레이드 가이드</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/contributions">기여 가이드</a></li>
        </ul>
    </li>
    <li>Setup
        <ul>
            <li><a href="/laravel-korean-docs/docs/5.0/installation">설치하기</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/configuration">설정</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/homestead">라라벨 홈스테드</a></li>
        </ul>
    </li>
    <li>The Basics
        <ul>
            <li><a href="/laravel-korean-docs/docs/5.0/routing">HTTP 라우팅</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/middleware">HTTP 미들웨어</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/controllers">HTTP 컨트롤러</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/requests">Requests</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/responses">Responses</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/views">뷰-Views</a></li>
        </ul>
    </li>
    <li>Architecture Foundations
        <ul>
            <li><a href="/laravel-korean-docs/docs/5.0/providers">서비스 프로바이더</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/container">서비스 컨테이너</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/contracts">Contracts</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/facades">파사드</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/lifecycle">라이프사이클</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/structure">어플리케이션 구조</a></li>
        </ul>
    </li>
    <li>Services
        <ul>
            <li><a href="/laravel-korean-docs/docs/5.0/authentication">인증</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/billing">라라벨 캐셔</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/cache">캐시</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/collections">컬렉션</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/bus">커맨드 버스</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/extending">프레임워크의 확장</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/elixir">라라벨 엘릭서</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/encryption">암호화</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/envoy">Envoy</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/errors">에러와 로깅</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/events">이벤트</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/filesystem">파일시스템 / 클라우드 스토리지</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/hashing">해시</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/helpers">헬퍼 함수</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/localization">지역화-다국어</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/mail">메일</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/packages">패키지 개발</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/pagination">페이지네이션</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/queues">큐</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/session">세션</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/templates">템플릿</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/testing">테스팅</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/validation">Validation</a></li>
        </ul>
    </li>
    <li>Database
        <ul>
            <li><a href="/laravel-korean-docs/docs/5.0/database">기본적인 데이터 베이스 사용법</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/queries">쿼리 빌더</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/eloquent">Eloquent ORM</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/schema">스키마 빌더</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/migrations">마이그레이션과 시딩</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/redis">Redis</a></li>
        </ul>
    </li>
    <li>Artisan CLI
        <ul>
            <li><a href="/laravel-korean-docs/docs/5.0/artisan">아티즌 CLI</a></li>
            <li><a href="/laravel-korean-docs/docs/5.0/commands">아티즌 명령어 개발하기</a></li>
        </ul>
    </li>
</ul>
            </section>

      <article class="content">
      <h1 id="eloquent-orm">Eloquent ORM</h1>

<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#basic-usage">Basic Usage</a></li>
<li><a href="#mass-assignment">Mass Assignment</a></li>
<li><a href="#insert-update-delete">Insert, Update, Delete</a></li>
<li><a href="#soft-deleting">Soft Deleting</a></li>
<li><a href="#timestamps">Timestamps</a></li>
<li><a href="#query-scopes">Query Scopes</a></li>
<li><a href="#global-scopes">Global Scopes</a></li>
<li><a href="#relationships">Relationships</a></li>
<li><a href="#querying-relations">Querying Relations</a></li>
<li><a href="#eager-loading">Eager Loading</a></li>
<li><a href="#inserting-related-models">Inserting Related Models</a></li>
<li><a href="#touching-parent-timestamps">Touching Parent Timestamps</a></li>
<li><a href="#working-with-pivot-tables">Working With Pivot Tables</a></li>
<li><a href="#collections">Collections</a></li>
<li><a href="#accessors-and-mutators">Accessors &amp; Mutators</a></li>
<li><a href="#date-mutators">Date Mutators</a></li>
<li><a href="#attribute-casting">Attribute Casting</a></li>
<li><a href="#model-events">Model Events</a></li>
<li><a href="#model-observers">Model Observers</a></li>
<li><a href="#model-url-generation">Model URL Generation</a></li>
<li><a href="#converting-to-arrays-or-json">Converting To Arrays / JSON</a></li>
</ul>

<p><a name="introduction"></a></p>

<h2 id="introduction">Introduction</h2>

<p>The Eloquent ORM included with Laravel provides a beautiful, simple ActiveRecord implementation for working with your database. Each database table has a corresponding &quot;Model&quot; which is used to interact with that table.</p>

<p>Before getting started, be sure to configure a database connection in <code>config/database.php</code>.</p>

<p><a name="basic-usage"></a></p>

<h2 id="basic-usage">Basic Usage</h2>

<p>To get started, create an Eloquent model. Models typically live in the <code>app</code> directory, but you are free to place them anywhere that can be auto-loaded according to your <code>composer.json</code> file. All Eloquent models extend <code>Illuminate\Database\Eloquent\Model</code>.</p>

<h4 id="defining-an-eloquent-model">Defining An Eloquent Model</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {}
</code></pre></div>
<p>You may also generate Eloquent models using the <code>make:model</code> command:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">php artisan make:model User
</code></pre></div>
<p>Note that we did not tell Eloquent which table to use for our <code>User</code> model. The &quot;snake case&quot;, plural name of the class will be used as the table name unless another name is explicitly specified. So, in this case, Eloquent will assume the <code>User</code> model stores records in the <code>users</code> table. You may specify a custom table by defining a <code>table</code> property on your model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {

    protected $table = &#39;my_users&#39;;

}
</code></pre></div>
<blockquote>
<p><strong>Note:</strong> Eloquent will also assume that each table has a primary key column named <code>id</code>. You may define a <code>primaryKey</code> property to override this convention. Likewise, you may define a <code>connection</code> property to override the name of the database connection that should be used when utilizing the model.</p>
</blockquote>

<p>Once a model is defined, you are ready to start retrieving and creating records in your table. Note that you will need to place <code>updated_at</code> and <code>created_at</code> columns on your table by default. If you do not wish to have these columns automatically maintained, set the <code>$timestamps</code> property on your model to <code>false</code>.</p>

<h4 id="retrieving-all-records">Retrieving All Records</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">$users = User::all();
</code></pre></div>
<h4 id="retrieving-a-record-by-primary-key">Retrieving A Record By Primary Key</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user = User::find(1);

var_dump($user-&gt;name);
</code></pre></div>
<blockquote>
<p><strong>Note:</strong> All methods available on the <a href="/docs/queries">query builder</a> are also available when querying Eloquent models.</p>
</blockquote>

<h4 id="retrieving-a-model-by-primary-key-or-throw-an-exception">Retrieving A Model By Primary Key Or Throw An Exception</h4>

<p>Sometimes you may wish to throw an exception if a model is not found. To do this, you may use the <code>firstOrFail</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$model = User::findOrFail(1);

$model = User::where(&#39;votes&#39;, &#39;&gt;&#39;, 100)-&gt;firstOrFail();
</code></pre></div>
<p>Doing this will let you catch the exception so you can log and display an error page as necessary. To catch the <code>ModelNotFoundException</code>, add some logic to your <code>app/Exceptions/Handler.php</code> file.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">use Illuminate\Database\Eloquent\ModelNotFoundException;

class Handler extends ExceptionHandler {

    public function render($request, Exception $e)
    {
        if ($e instanceof ModelNotFoundException)
        {
            // Custom logic for model not found...
        }

        return parent::render($request, $e);
    }

}
</code></pre></div>
<h4 id="querying-using-eloquent-models">Querying Using Eloquent Models</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">$users = User::where(&#39;votes&#39;, &#39;&gt;&#39;, 100)-&gt;take(10)-&gt;get();

foreach ($users as $user)
{
    var_dump($user-&gt;name);
}
</code></pre></div>
<h4 id="eloquent-aggregates">Eloquent Aggregates</h4>

<p>Of course, you may also use the query builder aggregate functions.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$count = User::where(&#39;votes&#39;, &#39;&gt;&#39;, 100)-&gt;count();
</code></pre></div>
<p>If you are unable to generate the query you need via the fluent interface, feel free to use <code>whereRaw</code>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$users = User::whereRaw(&#39;age &gt; ? and votes = 100&#39;, [25])-&gt;get();
</code></pre></div>
<h4 id="chunking-results">Chunking Results</h4>

<p>If you need to process a lot (thousands) of Eloquent records, using the <code>chunk</code> command will allow you to do without eating all of your RAM:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">User::chunk(200, function($users)
{
    foreach ($users as $user)
    {
        //
    }
});
</code></pre></div>
<p>The first argument passed to the method is the number of records you wish to receive per &quot;chunk&quot;. The Closure passed as the second argument will be called for each chunk that is pulled from the database.</p>

<h4 id="specifying-the-query-connection">Specifying The Query Connection</h4>

<p>You may also specify which database connection should be used when running an Eloquent query. Simply use the <code>on</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user = User::on(&#39;connection-name&#39;)-&gt;find(1);
</code></pre></div>
<p>If you are using <a href="/docs/5.0/database#read-write-connections">read / write connections</a>, you may force the query to use the &quot;write&quot; connection with the following method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user = User::onWriteConnection()-&gt;find(1);
</code></pre></div>
<p><a name="mass-assignment"></a></p>

<h2 id="mass-assignment">Mass Assignment</h2>

<p>When creating a new model, you pass an array of attributes to the model constructor. These attributes are then assigned to the model via mass-assignment. This is convenient; however, can be a <strong>serious</strong> security concern when blindly passing user input into a model. If user input is blindly passed into a model, the user is free to modify <strong>any</strong> and <strong>all</strong> of the model&#39;s attributes. For this reason, all Eloquent models protect against mass-assignment by default.</p>

<p>To get started, set the <code>fillable</code> or <code>guarded</code> properties on your model.</p>

<h4 id="defining-fillable-attributes-on-a-model">Defining Fillable Attributes On A Model</h4>

<p>The <code>fillable</code> property specifies which attributes should be mass-assignable. This can be set at the class or instance level.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {

    protected $fillable = [&#39;first_name&#39;, &#39;last_name&#39;, &#39;email&#39;];

}
</code></pre></div>
<p>In this example, only the three listed attributes will be mass-assignable.</p>

<h4 id="defining-guarded-attributes-on-a-model">Defining Guarded Attributes On A Model</h4>

<p>The inverse of <code>fillable</code> is <code>guarded</code>, and serves as a &quot;black-list&quot; instead of a &quot;white-list&quot;:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {

    protected $guarded = [&#39;id&#39;, &#39;password&#39;];

}
</code></pre></div>
<blockquote>
<p><strong>Note:</strong> When using <code>guarded</code>, you should still never pass <code>Input::get()</code> or any raw array of user controlled input into a <code>save</code> or <code>update</code> method, as any column that is not guarded may be updated.</p>
</blockquote>

<h4 id="blocking-all-attributes-from-mass-assignment">Blocking All Attributes From Mass Assignment</h4>

<p>In the example above, the <code>id</code> and <code>password</code> attributes may <strong>not</strong> be mass assigned. All other attributes will be mass assignable. You may also block <strong>all</strong> attributes from mass assignment using the guard property:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">protected $guarded = [&#39;*&#39;];
</code></pre></div>
<p><a name="insert-update-delete"></a></p>

<h2 id="insert,-update,-delete">Insert, Update, Delete</h2>

<p>To create a new record in the database from a model, simply create a new model instance and call the <code>save</code> method.</p>

<h4 id="saving-a-new-model">Saving A New Model</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user = new User;

$user-&gt;name = &#39;John&#39;;

$user-&gt;save();
</code></pre></div>
<blockquote>
<p><strong>Note:</strong> Typically, your Eloquent models will have auto-incrementing keys. However, if you wish to specify your own keys, set the <code>incrementing</code> property on your model to <code>false</code>.</p>
</blockquote>

<p>You may also use the <code>create</code> method to save a new model in a single line. The inserted model instance will be returned to you from the method. However, before doing so, you will need to specify either a <code>fillable</code> or <code>guarded</code> attribute on the model, as all Eloquent models protect against mass-assignment.</p>

<p>After saving or creating a new model that uses auto-incrementing IDs, you may retrieve the ID by accessing the object&#39;s <code>id</code> attribute:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$insertedId = $user-&gt;id;
</code></pre></div>
<h4 id="setting-the-guarded-attributes-on-the-model">Setting The Guarded Attributes On The Model</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {

    protected $guarded = [&#39;id&#39;, &#39;account_id&#39;];

}
</code></pre></div>
<h4 id="using-the-model-create-method">Using The Model Create Method</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">// Create a new user in the database...
$user = User::create([&#39;name&#39; =&gt; &#39;John&#39;]);

// Retrieve the user by the attributes, or create it if it doesn&#39;t exist...
$user = User::firstOrCreate([&#39;name&#39; =&gt; &#39;John&#39;]);

// Retrieve the user by the attributes, or instantiate a new instance...
$user = User::firstOrNew([&#39;name&#39; =&gt; &#39;John&#39;]);
</code></pre></div>
<h4 id="updating-a-retrieved-model">Updating A Retrieved Model</h4>

<p>To update a model, you may retrieve it, change an attribute, and use the <code>save</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user = User::find(1);

$user-&gt;email = &#39;john@foo.com&#39;;

$user-&gt;save();
</code></pre></div>
<h4 id="saving-a-model-and-relationships">Saving A Model And Relationships</h4>

<p>Sometimes you may wish to save not only a model, but also all of its relationships. To do so, you may use the <code>push</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user-&gt;push();
</code></pre></div>
<p>You may also run updates as queries against a set of models:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$affectedRows = User::where(&#39;votes&#39;, &#39;&gt;&#39;, 100)-&gt;update([&#39;status&#39; =&gt; 2]);
</code></pre></div>
<blockquote>
<p><strong>Note:</strong> No model events are fired when updating a set of models via the Eloquent query builder.</p>
</blockquote>

<h4 id="deleting-an-existing-model">Deleting An Existing Model</h4>

<p>To delete a model, simply call the <code>delete</code> method on the instance:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user = User::find(1);

$user-&gt;delete();
</code></pre></div>
<h4 id="deleting-an-existing-model-by-key">Deleting An Existing Model By Key</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">User::destroy(1);

User::destroy([1, 2, 3]);

User::destroy(1, 2, 3);
</code></pre></div>
<p>Of course, you may also run a delete query on a set of models:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$affectedRows = User::where(&#39;votes&#39;, &#39;&gt;&#39;, 100)-&gt;delete();
</code></pre></div>
<h4 id="updating-only-the-model&#39;s-timestamps">Updating Only The Model&#39;s Timestamps</h4>

<p>If you wish to simply update the timestamps on a model, you may use the <code>touch</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user-&gt;touch();
</code></pre></div>
<p><a name="soft-deleting"></a></p>

<h2 id="soft-deleting">Soft Deleting</h2>

<p>When soft deleting a model, it is not actually removed from your database. Instead, a <code>deleted_at</code> timestamp is set on the record. To enable soft deletes for a model, apply the <code>SoftDeletes</code> to the model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">use Illuminate\Database\Eloquent\SoftDeletes;

class User extends Model {

    use SoftDeletes;

    protected $dates = [&#39;deleted_at&#39;];

}
</code></pre></div>
<p>To add a <code>deleted_at</code> column to your table, you may use the <code>softDeletes</code> method from a migration:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$table-&gt;softDeletes();
</code></pre></div>
<p>Now, when you call the <code>delete</code> method on the model, the <code>deleted_at</code> column will be set to the current timestamp. When querying a model that uses soft deletes, the &quot;deleted&quot; models will not be included in query results.</p>

<h4 id="forcing-soft-deleted-models-into-results">Forcing Soft Deleted Models Into Results</h4>

<p>To force soft deleted models to appear in a result set, use the <code>withTrashed</code> method on the query:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$users = User::withTrashed()-&gt;where(&#39;account_id&#39;, 1)-&gt;get();
</code></pre></div>
<p>The <code>withTrashed</code> method may be used on a defined relationship:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user-&gt;posts()-&gt;withTrashed()-&gt;get();
</code></pre></div>
<p>If you wish to <strong>only</strong> receive soft deleted models in your results, you may use the <code>onlyTrashed</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$users = User::onlyTrashed()-&gt;where(&#39;account_id&#39;, 1)-&gt;get();
</code></pre></div>
<p>To restore a soft deleted model into an active state, use the <code>restore</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user-&gt;restore();
</code></pre></div>
<p>You may also use the <code>restore</code> method on a query:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">User::withTrashed()-&gt;where(&#39;account_id&#39;, 1)-&gt;restore();
</code></pre></div>
<p>Like with <code>withTrashed</code>, the <code>restore</code> method may also be used on relationships:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user-&gt;posts()-&gt;restore();
</code></pre></div>
<p>If you wish to truly remove a model from the database, you may use the <code>forceDelete</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user-&gt;forceDelete();
</code></pre></div>
<p>The <code>forceDelete</code> method also works on relationships:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user-&gt;posts()-&gt;forceDelete();
</code></pre></div>
<p>To determine if a given model instance has been soft deleted, you may use the <code>trashed</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">if ($user-&gt;trashed())
{
    //
}
</code></pre></div>
<p><a name="timestamps"></a></p>

<h2 id="timestamps">Timestamps</h2>

<p>By default, Eloquent will maintain the <code>created_at</code> and <code>updated_at</code> columns on your database table automatically. Simply add these <code>timestamp</code> columns to your table and Eloquent will take care of the rest. If you do not wish for Eloquent to maintain these columns, add the following property to your model:</p>

<h4 id="disabling-auto-timestamps">Disabling Auto Timestamps</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {

    protected $table = &#39;users&#39;;

    public $timestamps = false;

}
</code></pre></div>
<h4 id="providing-a-custom-timestamp-format">Providing A Custom Timestamp Format</h4>

<p>If you wish to customize the format of your timestamps, you may override the <code>getDateFormat</code> method in your model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {

    protected function getDateFormat()
    {
        return &#39;U&#39;;
    }

}
</code></pre></div>
<p><a name="query-scopes"></a></p>

<h2 id="query-scopes">Query Scopes</h2>

<h4 id="defining-a-query-scope">Defining A Query Scope</h4>

<p>Scopes allow you to easily re-use query logic in your models. To define a scope, simply prefix a model method with <code>scope</code>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {

    public function scopePopular($query)
    {
        return $query-&gt;where(&#39;votes&#39;, &#39;&gt;&#39;, 100);
    }

    public function scopeWomen($query)
    {
        return $query-&gt;whereGender(&#39;W&#39;);
    }

}
</code></pre></div>
<h4 id="utilizing-a-query-scope">Utilizing A Query Scope</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">$users = User::popular()-&gt;women()-&gt;orderBy(&#39;created_at&#39;)-&gt;get();
</code></pre></div>
<h4 id="dynamic-scopes">Dynamic Scopes</h4>

<p>Sometimes you may wish to define a scope that accepts parameters. Just add your parameters to your scope function:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {

    public function scopeOfType($query, $type)
    {
        return $query-&gt;whereType($type);
    }

}
</code></pre></div>
<p>Then pass the parameter into the scope call:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$users = User::ofType(&#39;member&#39;)-&gt;get();
</code></pre></div>
<p><a name="global-scopes"></a></p>

<h2 id="global-scopes">Global Scopes</h2>

<p>Sometimes you may wish to define a scope that applies to all queries performed on a model. In essence, this is how Eloquent&#39;s own &quot;soft delete&quot; feature works. Global scopes are defined using a combination of PHP traits and an implementation of <code>Illuminate\Database\Eloquent\ScopeInterface</code>.</p>

<p>First, let&#39;s define a trait. For this example, we&#39;ll use the <code>SoftDeletes</code> that ships with Laravel:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">trait SoftDeletes {

    /**
     * Boot the soft deleting trait for a model.
     *
     * @return void
     */
    public static function bootSoftDeletes()
    {
        static::addGlobalScope(new SoftDeletingScope);
    }

}
</code></pre></div>
<p>If an Eloquent model uses a trait that has a method matching the <code>bootNameOfTrait</code> naming convention, that trait method will be called when the Eloquent model is booted, giving you an opportunity to register a global scope, or do anything else you want. A scope must implement <code>ScopeInterface</code>, which specifies two methods: <code>apply</code> and <code>remove</code>.</p>

<p>The <code>apply</code> method receives an <code>Illuminate\Database\Eloquent\Builder</code> query builder object and the <code>Model</code> it&#39;s applied to, and is responsible for adding any additional <code>where</code> clauses that the scope wishes to add. The <code>remove</code> method also receives a <code>Builder</code> object and <code>Model</code> and is responsible for reversing the action taken by <code>apply</code>. In other words, <code>remove</code> should remove the <code>where</code> clause (or any other clause) that was added. So, for our <code>SoftDeletingScope</code>, the methods look something like this:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/**
 * Apply the scope to a given Eloquent query builder.
 *
 * @param  \Illuminate\Database\Eloquent\Builder  $builder
 * @param  \Illuminate\Database\Eloquent\Model  $model
 * @return void
 */
public function apply(Builder $builder, Model $model)
{
    $builder-&gt;whereNull($model-&gt;getQualifiedDeletedAtColumn());

    $this-&gt;extend($builder);
}

/**
 * Remove the scope from the given Eloquent query builder.
 *
 * @param  \Illuminate\Database\Eloquent\Builder  $builder
 * @param  \Illuminate\Database\Eloquent\Model  $model
 * @return void
 */
public function remove(Builder $builder, Model $model)
{
    $column = $model-&gt;getQualifiedDeletedAtColumn();

    $query = $builder-&gt;getQuery();

    foreach ((array) $query-&gt;wheres as $key =&gt; $where)
    {
        // If the where clause is a soft delete date constraint, we will remove it from
        // the query and reset the keys on the wheres. This allows this developer to
        // include deleted model in a relationship result set that is lazy loaded.
        if ($this-&gt;isSoftDeleteConstraint($where, $column))
        {
            unset($query-&gt;wheres[$key]);

            $query-&gt;wheres = array_values($query-&gt;wheres);
        }
    }
}
</code></pre></div>
<p><a name="relationships"></a></p>

<h2 id="relationships">Relationships</h2>

<p>Of course, your database tables are probably related to one another. For example, a blog post may have many comments, or an order could be related to the user who placed it. Eloquent makes managing and working with these relationships easy. Laravel supports many types of relationships:</p>

<ul>
<li><a href="#one-to-one">One To One</a></li>
<li><a href="#one-to-many">One To Many</a></li>
<li><a href="#many-to-many">Many To Many</a></li>
<li><a href="#has-many-through">Has Many Through</a></li>
<li><a href="#polymorphic-relations">Polymorphic Relations</a></li>
<li><a href="#many-to-many-polymorphic-relations">Many To Many Polymorphic Relations</a></li>
</ul>

<p><a name="one-to-one"></a></p>

<h3 id="one-to-one">One To One</h3>

<h4 id="defining-a-one-to-one-relation">Defining A One To One Relation</h4>

<p>A one-to-one relationship is a very basic relation. For example, a <code>User</code> model might have one <code>Phone</code>. We can define this relation in Eloquent:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {

    public function phone()
    {
        return $this-&gt;hasOne(&#39;App\Phone&#39;);
    }

}
</code></pre></div>
<p>The first argument passed to the <code>hasOne</code> method is the name of the related model. Once the relationship is defined, we may retrieve it using Eloquent&#39;s <a href="#dynamic-properties">dynamic properties</a>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$phone = User::find(1)-&gt;phone;
</code></pre></div>
<p>The SQL performed by this statement will be as follows:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">select * from users where id = 1

select * from phones where user_id = 1
</code></pre></div>
<p>Take note that Eloquent assumes the foreign key of the relationship based on the model name. In this case, <code>Phone</code> model is assumed to use a <code>user_id</code> foreign key. If you wish to override this convention, you may pass a second argument to the <code>hasOne</code> method. Furthermore, you may pass a third argument to the method to specify which local column that should be used for the association:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">return $this-&gt;hasOne(&#39;App\Phone&#39;, &#39;foreign_key&#39;);

return $this-&gt;hasOne(&#39;App\Phone&#39;, &#39;foreign_key&#39;, &#39;local_key&#39;);
</code></pre></div>
<h4 id="defining-the-inverse-of-a-relation">Defining The Inverse Of A Relation</h4>

<p>To define the inverse of the relationship on the <code>Phone</code> model, we use the <code>belongsTo</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Phone extends Model {

    public function user()
    {
        return $this-&gt;belongsTo(&#39;App\User&#39;);
    }

}
</code></pre></div>
<p>In the example above, Eloquent will look for a <code>user_id</code> column on the <code>phones</code> table. If you would like to define a different foreign key column, you may pass it as the second argument to the <code>belongsTo</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Phone extends Model {

    public function user()
    {
        return $this-&gt;belongsTo(&#39;App\User&#39;, &#39;local_key&#39;);
    }

}
</code></pre></div>
<p>Additionally, you pass a third parameter which specifies the name of the associated column on the parent table:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Phone extends Model {

    public function user()
    {
        return $this-&gt;belongsTo(&#39;App\User&#39;, &#39;local_key&#39;, &#39;parent_key&#39;);
    }

}
</code></pre></div>
<p><a name="one-to-many"></a></p>

<h3 id="one-to-many">One To Many</h3>

<p>An example of a one-to-many relation is a blog post that &quot;has many&quot; comments. We can model this relation like so:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Post extends Model {

    public function comments()
    {
        return $this-&gt;hasMany(&#39;App\Comment&#39;);
    }

}
</code></pre></div>
<p>Now we can access the post&#39;s comments through the <a href="#dynamic-properties">dynamic property</a>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$comments = Post::find(1)-&gt;comments;
</code></pre></div>
<p>If you need to add further constraints to which comments are retrieved, you may call the <code>comments</code> method and continue chaining conditions:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$comments = Post::find(1)-&gt;comments()-&gt;where(&#39;title&#39;, &#39;=&#39;, &#39;foo&#39;)-&gt;first();
</code></pre></div>
<p>Again, you may override the conventional foreign key by passing a second argument to the <code>hasMany</code> method. And, like the <code>hasOne</code> relation, the local column may also be specified:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">return $this-&gt;hasMany(&#39;App\Comment&#39;, &#39;foreign_key&#39;);

return $this-&gt;hasMany(&#39;App\Comment&#39;, &#39;foreign_key&#39;, &#39;local_key&#39;);
</code></pre></div>
<h4 id="defining-the-inverse-of-a-relation">Defining The Inverse Of A Relation</h4>

<p>To define the inverse of the relationship on the <code>Comment</code> model, we use the <code>belongsTo</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Comment extends Model {

    public function post()
    {
        return $this-&gt;belongsTo(&#39;App\Post&#39;);
    }

}
</code></pre></div>
<p><a name="many-to-many"></a></p>

<h3 id="many-to-many">Many To Many</h3>

<p>Many-to-many relations are a more complicated relationship type. An example of such a relationship is a user with many roles, where the roles are also shared by other users. For example, many users may have the role of &quot;Admin&quot;. Three database tables are needed for this relationship: <code>users</code>, <code>roles</code>, and <code>role_user</code>. The <code>role_user</code> table is derived from the alphabetical order of the related model names, and should have <code>user_id</code> and <code>role_id</code> columns.</p>

<p>We can define a many-to-many relation using the <code>belongsToMany</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {

    public function roles()
    {
        return $this-&gt;belongsToMany(&#39;App\Role&#39;);
    }

}
</code></pre></div>
<p>Now, we can retrieve the roles through the <code>User</code> model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$roles = User::find(1)-&gt;roles;
</code></pre></div>
<p>If you would like to use an unconventional table name for your pivot table, you may pass it as the second argument to the <code>belongsToMany</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">return $this-&gt;belongsToMany(&#39;App\Role&#39;, &#39;user_roles&#39;);
</code></pre></div>
<p>You may also override the conventional associated keys:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">return $this-&gt;belongsToMany(&#39;App\Role&#39;, &#39;user_roles&#39;, &#39;user_id&#39;, &#39;foo_id&#39;);
</code></pre></div>
<p>Of course, you may also define the inverse of the relationship on the <code>Role</code> model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Role extends Model {

    public function users()
    {
        return $this-&gt;belongsToMany(&#39;App\User&#39;);
    }

}
</code></pre></div>
<p><a name="has-many-through"></a></p>

<h3 id="has-many-through">Has Many Through</h3>

<p>The &quot;has many through&quot; relation provides a convenient short-cut for accessing distant relations via an intermediate relation. For example, a <code>Country</code> model might have many <code>Post</code> through a <code>User</code> model. The tables for this relationship would look like this:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">countries
    id - integer
    name - string

users
    id - integer
    country_id - integer
    name - string

posts
    id - integer
    user_id - integer
    title - string
</code></pre></div>
<p>Even though the <code>posts</code> table does not contain a <code>country_id</code> column, the <code>hasManyThrough</code> relation will allow us to access a country&#39;s posts via <code>$country-&gt;posts</code>. Let&#39;s define the relationship:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Country extends Model {

    public function posts()
    {
        return $this-&gt;hasManyThrough(&#39;App\Post&#39;, &#39;App\User&#39;);
    }

}
</code></pre></div>
<p>If you would like to manually specify the keys of the relationship, you may pass them as the third and fourth arguments to the method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Country extends Model {

    public function posts()
    {
        return $this-&gt;hasManyThrough(&#39;App\Post&#39;, &#39;App\User&#39;, &#39;country_id&#39;, &#39;user_id&#39;);
    }

}
</code></pre></div>
<p><a name="polymorphic-relations"></a></p>

<h3 id="polymorphic-relations">Polymorphic Relations</h3>

<p>Polymorphic relations allow a model to belong to more than one other model, on a single association. For example, you might have a photo model that belongs to either a staff model or an order model. We would define this relation like so:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Photo extends Model {

    public function imageable()
    {
        return $this-&gt;morphTo();
    }

}

class Staff extends Model {

    public function photos()
    {
        return $this-&gt;morphMany(&#39;App\Photo&#39;, &#39;imageable&#39;);
    }

}

class Order extends Model {

    public function photos()
    {
        return $this-&gt;morphMany(&#39;App\Photo&#39;, &#39;imageable&#39;);
    }

}
</code></pre></div>
<h4 id="retrieving-a-polymorphic-relation">Retrieving A Polymorphic Relation</h4>

<p>Now, we can retrieve the photos for either a staff member or an order:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$staff = Staff::find(1);

foreach ($staff-&gt;photos as $photo)
{
    //
}
</code></pre></div>
<h4 id="retrieving-the-owner-of-a-polymorphic-relation">Retrieving The Owner Of A Polymorphic Relation</h4>

<p>However, the true &quot;polymorphic&quot; magic is when you access the staff or order from the <code>Photo</code> model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$photo = Photo::find(1);

$imageable = $photo-&gt;imageable;
</code></pre></div>
<p>The <code>imageable</code> relation on the <code>Photo</code> model will return either a <code>Staff</code> or <code>Order</code> instance, depending on which type of model owns the photo.</p>

<h4 id="polymorphic-relation-table-structure">Polymorphic Relation Table Structure</h4>

<p>To help understand how this works, let&#39;s explore the database structure for a polymorphic relation:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">staff
    id - integer
    name - string

orders
    id - integer
    price - integer

photos
    id - integer
    path - string
    imageable_id - integer
    imageable_type - string
</code></pre></div>
<p>The key fields to notice here are the <code>imageable_id</code> and <code>imageable_type</code> on the <code>photos</code> table. The ID will contain the ID value of, in this example, the owning staff or order, while the type will contain the class name of the owning model. This is what allows the ORM to determine which type of owning model to return when accessing the <code>imageable</code> relation.</p>

<p><a name="many-to-many-polymorphic-relations"></a></p>

<h3 id="many-to-many-polymorphic-relations">Many To Many Polymorphic Relations</h3>

<h4 id="polymorphic-many-to-many-relation-table-structure">Polymorphic Many To Many Relation Table Structure</h4>

<p>In addition to traditional polymorphic relations, you may also specify many-to-many polymorphic relations. For example, a blog <code>Post</code> and <code>Video</code> model could share a polymorphic relation to a <code>Tag</code> model. First, let&#39;s examine the table structure:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">posts
    id - integer
    name - string

videos
    id - integer
    name - string

tags
    id - integer
    name - string

taggables
    tag_id - integer
    taggable_id - integer
    taggable_type - string
</code></pre></div>
<p>Next, we&#39;re ready to setup the relationships on the model. The <code>Post</code> and <code>Video</code> model will both have a <code>morphToMany</code> relationship via a <code>tags</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Post extends Model {

    public function tags()
    {
        return $this-&gt;morphToMany(&#39;App\Tag&#39;, &#39;taggable&#39;);
    }

}
</code></pre></div>
<p>The <code>Tag</code> model may define a method for each of its relationships:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Tag extends Model {

    public function posts()
    {
        return $this-&gt;morphedByMany(&#39;App\Post&#39;, &#39;taggable&#39;);
    }

    public function videos()
    {
        return $this-&gt;morphedByMany(&#39;App\Video&#39;, &#39;taggable&#39;);
    }

}
</code></pre></div>
<p><a name="querying-relations"></a></p>

<h2 id="querying-relations">Querying Relations</h2>

<h4 id="querying-relations-when-selecting">Querying Relations When Selecting</h4>

<p>When accessing the records for a model, you may wish to limit your results based on the existence of a relationship. For example, you wish to pull all blog posts that have at least one comment. To do so, you may use the <code>has</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$posts = Post::has(&#39;comments&#39;)-&gt;get();
</code></pre></div>
<p>You may also specify an operator and a count:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$posts = Post::has(&#39;comments&#39;, &#39;&gt;=&#39;, 3)-&gt;get();
</code></pre></div>
<p>Nested <code>has</code> statements may also be constructed using &quot;dot&quot; notation:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$posts = Post::has(&#39;comments.votes&#39;)-&gt;get();
</code></pre></div>
<p>If you need even more power, you may use the <code>whereHas</code> and <code>orWhereHas</code> methods to put &quot;where&quot; conditions on your <code>has</code> queries:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$posts = Post::whereHas(&#39;comments&#39;, function($q)
{
    $q-&gt;where(&#39;content&#39;, &#39;like&#39;, &#39;foo%&#39;);

})-&gt;get();
</code></pre></div>
<p><a name="dynamic-properties"></a></p>

<h3 id="dynamic-properties">Dynamic Properties</h3>

<p>Eloquent allows you to access your relations via dynamic properties. Eloquent will automatically load the relationship for you, and is even smart enough to know whether to call the <code>get</code> (for one-to-many relationships) or <code>first</code> (for one-to-one relationships) method.  It will then be accessible via a dynamic property by the same name as the relation. For example, with the following model <code>$phone</code>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Phone extends Model {

    public function user()
    {
        return $this-&gt;belongsTo(&#39;App\User&#39;);
    }

}

$phone = Phone::find(1);
</code></pre></div>
<p>Instead of echoing the user&#39;s email like this:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">echo $phone-&gt;user()-&gt;first()-&gt;email;
</code></pre></div>
<p>It may be shortened to simply:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">echo $phone-&gt;user-&gt;email;
</code></pre></div>
<blockquote>
<p><strong>Note:</strong> Relationships that return many results will return an instance of the <code>Illuminate\Database\Eloquent\Collection</code> class.</p>
</blockquote>

<p><a name="eager-loading"></a></p>

<h2 id="eager-loading">Eager Loading</h2>

<p>Eager loading exists to alleviate the N + 1 query problem. For example, consider a <code>Book</code> model that is related to <code>Author</code>. The relationship is defined like so:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Book extends Model {

    public function author()
    {
        return $this-&gt;belongsTo(&#39;App\Author&#39;);
    }

}
</code></pre></div>
<p>Now, consider the following code:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">foreach (Book::all() as $book)
{
    echo $book-&gt;author-&gt;name;
}
</code></pre></div>
<p>This loop will execute 1 query to retrieve all of the books on the table, then another query for each book to retrieve the author. So, if we have 25 books, this loop would run 26 queries.</p>

<p>Thankfully, we can use eager loading to drastically reduce the number of queries. The relationships that should be eager loaded may be specified via the <code>with</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">foreach (Book::with(&#39;author&#39;)-&gt;get() as $book)
{
    echo $book-&gt;author-&gt;name;
}
</code></pre></div>
<p>In the loop above, only two queries will be executed:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">select * from books

select * from authors where id in (1, 2, 3, 4, 5, ...)
</code></pre></div>
<p>Wise use of eager loading can drastically increase the performance of your application.</p>

<p>Of course, you may eager load multiple relationships at one time:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$books = Book::with(&#39;author&#39;, &#39;publisher&#39;)-&gt;get();
</code></pre></div>
<p>You may even eager load nested relationships:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$books = Book::with(&#39;author.contacts&#39;)-&gt;get();
</code></pre></div>
<p>In the example above, the <code>author</code> relationship will be eager loaded, and the author&#39;s <code>contacts</code> relation will also be loaded.</p>

<h3 id="eager-load-constraints">Eager Load Constraints</h3>

<p>Sometimes you may wish to eager load a relationship, but also specify a condition for the eager load. Here&#39;s an example:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$users = User::with([&#39;posts&#39; =&gt; function($query)
{
    $query-&gt;where(&#39;title&#39;, &#39;like&#39;, &#39;%first%&#39;);

}])-&gt;get();
</code></pre></div>
<p>In this example, we&#39;re eager loading the user&#39;s posts, but only if the post&#39;s title column contains the word &quot;first&quot;.</p>

<p>Of course, eager loading Closures aren&#39;t limited to &quot;constraints&quot;. You may also apply orders:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$users = User::with([&#39;posts&#39; =&gt; function($query)
{
    $query-&gt;orderBy(&#39;created_at&#39;, &#39;desc&#39;);

}])-&gt;get();
</code></pre></div>
<h3 id="lazy-eager-loading">Lazy Eager Loading</h3>

<p>It is also possible to eagerly load related models directly from an already existing model collection. This may be useful when dynamically deciding whether to load related models or not, or in combination with caching.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$books = Book::all();

$books-&gt;load(&#39;author&#39;, &#39;publisher&#39;);
</code></pre></div>
<p>You may also pass a Closure to set constraints on the query:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$books-&gt;load([&#39;author&#39; =&gt; function($query)
{
    $query-&gt;orderBy(&#39;published_date&#39;, &#39;asc&#39;);
}]);
</code></pre></div>
<p><a name="inserting-related-models"></a></p>

<h2 id="inserting-related-models">Inserting Related Models</h2>

<h4 id="attaching-a-related-model">Attaching A Related Model</h4>

<p>You will often need to insert new related models. For example, you may wish to insert a new comment for a post. Instead of manually setting the <code>post_id</code> foreign key on the model, you may insert the new comment from its parent <code>Post</code> model directly:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$comment = new Comment([&#39;message&#39; =&gt; &#39;A new comment.&#39;]);

$post = Post::find(1);

$comment = $post-&gt;comments()-&gt;save($comment);
</code></pre></div>
<p>In this example, the <code>post_id</code> field will automatically be set on the inserted comment.</p>

<p>If you need to save multiple related models:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$comments = [
    new Comment([&#39;message&#39; =&gt; &#39;A new comment.&#39;]),
    new Comment([&#39;message&#39; =&gt; &#39;Another comment.&#39;]),
    new Comment([&#39;message&#39; =&gt; &#39;The latest comment.&#39;])
];

$post = Post::find(1);

$post-&gt;comments()-&gt;saveMany($comments);
</code></pre></div>
<h3 id="associating-models-(belongs-to)">Associating Models (Belongs To)</h3>

<p>When updating a <code>belongsTo</code> relationship, you may use the <code>associate</code> method. This method will set the foreign key on the child model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$account = Account::find(10);

$user-&gt;account()-&gt;associate($account);

$user-&gt;save();
</code></pre></div>
<h3 id="inserting-related-models-(many-to-many)">Inserting Related Models (Many To Many)</h3>

<p>You may also insert related models when working with many-to-many relations. Let&#39;s continue using our <code>User</code> and <code>Role</code> models as examples. We can easily attach new roles to a user using the <code>attach</code> method:</p>

<h4 id="attaching-many-to-many-models">Attaching Many To Many Models</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user = User::find(1);

$user-&gt;roles()-&gt;attach(1);
</code></pre></div>
<p>You may also pass an array of attributes that should be stored on the pivot table for the relation:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user-&gt;roles()-&gt;attach(1, [&#39;expires&#39; =&gt; $expires]);
</code></pre></div>
<p>Of course, the opposite of <code>attach</code> is <code>detach</code>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user-&gt;roles()-&gt;detach(1);
</code></pre></div>
<p>Both <code>attach</code> and <code>detach</code> also take arrays of IDs as input:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user = User::find(1);

$user-&gt;roles()-&gt;detach([1, 2, 3]);

$user-&gt;roles()-&gt;attach([1 =&gt; [&#39;attribute1&#39; =&gt; &#39;value1&#39;], 2, 3]);
</code></pre></div>
<h4 id="using-sync-to-attach-many-to-many-models">Using Sync To Attach Many To Many Models</h4>

<p>You may also use the <code>sync</code> method to attach related models. The <code>sync</code> method accepts an array of IDs to place on the pivot table. After this operation is complete, only the IDs in the array will be on the intermediate table for the model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user-&gt;roles()-&gt;sync([1, 2, 3]);
</code></pre></div>
<h4 id="adding-pivot-data-when-syncing">Adding Pivot Data When Syncing</h4>

<p>You may also associate other pivot table values with the given IDs:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user-&gt;roles()-&gt;sync([1 =&gt; [&#39;expires&#39; =&gt; true]]);
</code></pre></div>
<p>Sometimes you may wish to create a new related model and attach it in a single command. For this operation, you may use the <code>save</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$role = new Role([&#39;name&#39; =&gt; &#39;Editor&#39;]);

User::find(1)-&gt;roles()-&gt;save($role);
</code></pre></div>
<p>In this example, the new <code>Role</code> model will be saved and attached to the user model. You may also pass an array of attributes to place on the joining table for this operation:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">User::find(1)-&gt;roles()-&gt;save($role, [&#39;expires&#39; =&gt; $expires]);
</code></pre></div>
<p><a name="touching-parent-timestamps"></a></p>

<h2 id="touching-parent-timestamps">Touching Parent Timestamps</h2>

<p>When a model <code>belongsTo</code> another model, such as a <code>Comment</code> which belongs to a <code>Post</code>, it is often helpful to update the parent&#39;s timestamp when the child model is updated. For example, when a <code>Comment</code> model is updated, you may want to automatically touch the <code>updated_at</code> timestamp of the owning <code>Post</code>. Eloquent makes it easy. Just add a <code>touches</code> property containing the names of the relationships to the child model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Comment extends Model {

    protected $touches = [&#39;post&#39;];

    public function post()
    {
        return $this-&gt;belongsTo(&#39;App\Post&#39;);
    }

}
</code></pre></div>
<p>Now, when you update a <code>Comment</code>, the owning <code>Post</code> will have its <code>updated_at</code> column updated:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$comment = Comment::find(1);

$comment-&gt;text = &#39;Edit to this comment!&#39;;

$comment-&gt;save();
</code></pre></div>
<p><a name="working-with-pivot-tables"></a></p>

<h2 id="working-with-pivot-tables">Working With Pivot Tables</h2>

<p>As you have already learned, working with many-to-many relations requires the presence of an intermediate table. Eloquent provides some very helpful ways of interacting with this table. For example, let&#39;s assume our <code>User</code> object has many <code>Role</code> objects that it is related to. After accessing this relationship, we may access the <code>pivot</code> table on the models:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user = User::find(1);

foreach ($user-&gt;roles as $role)
{
    echo $role-&gt;pivot-&gt;created_at;
}
</code></pre></div>
<p>Notice that each <code>Role</code> model we retrieve is automatically assigned a <code>pivot</code> attribute. This attribute contains a model representing the intermediate table, and may be used as any other Eloquent model.</p>

<p>By default, only the keys will be present on the <code>pivot</code> object. If your pivot table contains extra attributes, you must specify them when defining the relationship:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">return $this-&gt;belongsToMany(&#39;App\Role&#39;)-&gt;withPivot(&#39;foo&#39;, &#39;bar&#39;);
</code></pre></div>
<p>Now the <code>foo</code> and <code>bar</code> attributes will be accessible on our <code>pivot</code> object for the <code>Role</code> model.</p>

<p>If you want your pivot table to have automatically maintained <code>created_at</code> and <code>updated_at</code> timestamps, use the <code>withTimestamps</code> method on the relationship definition:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">return $this-&gt;belongsToMany(&#39;App\Role&#39;)-&gt;withTimestamps();
</code></pre></div>
<h4 id="deleting-records-on-a-pivot-table">Deleting Records On A Pivot Table</h4>

<p>To delete all records on the pivot table for a model, you may use the <code>detach</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">User::find(1)-&gt;roles()-&gt;detach();
</code></pre></div>
<p>Note that this operation does not delete records from the <code>roles</code> table, but only from the pivot table.</p>

<h4 id="updating-a-record-on-a-pivot-table">Updating A Record On A Pivot Table</h4>

<p>Sometimes you may need to update your pivot table, but not detach it. If you wish to update your pivot table in place you may use <code>updateExistingPivot</code> method like so:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">User::find(1)-&gt;roles()-&gt;updateExistingPivot($roleId, $attributes);
</code></pre></div>
<h4 id="defining-a-custom-pivot-model">Defining A Custom Pivot Model</h4>

<p>Laravel also allows you to define a custom Pivot model. To define a custom model, first create your own &quot;Base&quot; model class that extends <code>Eloquent</code>. In your other Eloquent models, extend this custom base model instead of the default <code>Eloquent</code> base. In your base model, add the following function that returns an instance of your custom Pivot model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public function newPivot(Model $parent, array $attributes, $table, $exists)
{
    return new YourCustomPivot($parent, $attributes, $table, $exists);
}
</code></pre></div>
<p><a name="collections"></a></p>

<h2 id="collections">Collections</h2>

<p>All multi-result sets returned by Eloquent, either via the <code>get</code> method or a <code>relationship</code>, will return a collection object. This object implements the <code>IteratorAggregate</code> PHP interface so it can be iterated over like an array. However, this object also has a variety of other helpful methods for working with result sets.</p>

<h4 id="checking-if-a-collection-contains-a-key">Checking If A Collection Contains A Key</h4>

<p>For example, we may determine if a result set contains a given primary key using the <code>contains</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$roles = User::find(1)-&gt;roles;

if ($roles-&gt;contains(2))
{
    //
}
</code></pre></div>
<p>Collections may also be converted to an array or JSON:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$roles = User::find(1)-&gt;roles-&gt;toArray();

$roles = User::find(1)-&gt;roles-&gt;toJson();
</code></pre></div>
<p>If a collection is cast to a string, it will be returned as JSON:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$roles = (string) User::find(1)-&gt;roles;
</code></pre></div>
<h4 id="iterating-collections">Iterating Collections</h4>

<p>Eloquent collections also contain a few helpful methods for looping and filtering the items they contain:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$roles = $user-&gt;roles-&gt;each(function($role)
{
    //
});
</code></pre></div>
<h4 id="filtering-collections">Filtering Collections</h4>

<p>When filtering collections, the callback provided will be used as callback for <a href="http://php.net/manual/en/function.array-filter.php">array_filter</a>.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$users = $users-&gt;filter(function($user)
{
    return $user-&gt;isAdmin();
});
</code></pre></div>
<blockquote>
<p><strong>Note:</strong> When filtering a collection and converting it to JSON, try calling the <code>values</code> function first to reset the array&#39;s keys.</p>
</blockquote>

<h4 id="applying-a-callback-to-each-collection-object">Applying A Callback To Each Collection Object</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">$roles = User::find(1)-&gt;roles;

$roles-&gt;each(function($role)
{
    //
});
</code></pre></div>
<h4 id="sorting-a-collection-by-a-value">Sorting A Collection By A Value</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">$roles = $roles-&gt;sortBy(function($role)
{
    return $role-&gt;created_at;
});

$roles = $roles-&gt;sortByDesc(function($role)
{
    return $role-&gt;created_at;
});
</code></pre></div>
<h4 id="sorting-a-collection-by-a-value">Sorting A Collection By A Value</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">$roles = $roles-&gt;sortBy(&#39;created_at&#39;);

$roles = $roles-&gt;sortByDesc(&#39;created_at&#39;);
</code></pre></div>
<h4 id="returning-a-custom-collection-type">Returning A Custom Collection Type</h4>

<p>Sometimes, you may wish to return a custom Collection object with your own added methods. You may specify this on your Eloquent model by overriding the <code>newCollection</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {

    public function newCollection(array $models = [])
    {
        return new CustomCollection($models);
    }

}
</code></pre></div>
<p><a name="accessors-and-mutators"></a></p>

<h2 id="accessors-&amp;-mutators">Accessors &amp; Mutators</h2>

<h4 id="defining-an-accessor">Defining An Accessor</h4>

<p>Eloquent provides a convenient way to transform your model attributes when getting or setting them. Simply define a <code>getFooAttribute</code> method on your model to declare an accessor. Keep in mind that the methods should follow camel-casing, even though your database columns are snake-case:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {

    public function getFirstNameAttribute($value)
    {
        return ucfirst($value);
    }

}
</code></pre></div>
<p>In the example above, the <code>first_name</code> column has an accessor. Note that the value of the attribute is passed to the accessor.</p>

<h4 id="defining-a-mutator">Defining A Mutator</h4>

<p>Mutators are declared in a similar fashion:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {

    public function setFirstNameAttribute($value)
    {
        $this-&gt;attributes[&#39;first_name&#39;] = strtolower($value);
    }

}
</code></pre></div>
<p><a name="date-mutators"></a></p>

<h2 id="date-mutators">Date Mutators</h2>

<p>By default, Eloquent will convert the <code>created_at</code> and <code>updated_at</code> columns to instances of <a href="https://github.com/briannesbitt/Carbon">Carbon</a>, which provides an assortment of helpful methods, and extends the native PHP <code>DateTime</code> class.</p>

<p>You may customize which fields are automatically mutated, and even completely disable this mutation, by overriding the <code>getDates</code> method of the model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public function getDates()
{
    return [&#39;created_at&#39;];
}
</code></pre></div>
<p>When a column is considered a date, you may set its value to a UNIX timestamp, date string (<code>Y-m-d</code>), date-time string, and of course a <code>DateTime</code> / <code>Carbon</code> instance.</p>

<p>To totally disable date mutations, simply return an empty array from the <code>getDates</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public function getDates()
{
    return [];
}
</code></pre></div>
<p><a name="attribute-casting"></a></p>

<h2 id="attribute-casting">Attribute Casting</h2>

<p>If you have some attributes that you want to always convert to another data-type, you may add the attribute to the <code>casts</code> property of your model. Otherwise, you will have to define a mutator for each of the attributes, which can be time consuming. Here is an example of using the <code>casts</code> property:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/**
 * The attributes that should be casted to native types.
 *
 * @var array
 */
protected $casts = [
    &#39;is_admin&#39; =&gt; &#39;boolean&#39;,
];
</code></pre></div>
<p>Now the <code>is_admin</code> attribute will always be cast to a boolean when you access it, even if the underlying value is stored in the database as an integer. Other supported cast types are: <code>integer</code>, <code>real</code>, <code>float</code>, <code>double</code>, <code>string</code>, <code>boolean</code>, <code>object</code> and <code>array</code>.</p>

<p>The <code>array</code> cast is particularly useful for working with columns that are stored as serialized JSON. For example, if your database has a TEXT type field that contains serialized JSON, adding the <code>array</code> cast to that attribute will automatically deserialize the attribute to a PHP array when you access it on your Eloquent model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/**
 * The attributes that should be casted to native types.
 *
 * @var array
 */
protected $casts = [
    &#39;options&#39; =&gt; &#39;array&#39;,
];
</code></pre></div>
<p>Now, when you utilize the Eloquent model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user = User::find(1);

// $options is an array...
$options = $user-&gt;options;

// options is automatically serialized back to JSON...
$user-&gt;options = [&#39;foo&#39; =&gt; &#39;bar&#39;];
</code></pre></div>
<p><a name="model-events"></a></p>

<h2 id="model-events">Model Events</h2>

<p>Eloquent models fire several events, allowing you to hook into various points in the model&#39;s lifecycle using the following methods: <code>creating</code>, <code>created</code>, <code>updating</code>, <code>updated</code>, <code>saving</code>, <code>saved</code>, <code>deleting</code>, <code>deleted</code>, <code>restoring</code>, <code>restored</code>.</p>

<p>Whenever a new item is saved for the first time, the <code>creating</code> and <code>created</code> events will fire. If an item is not new and the <code>save</code> method is called, the <code>updating</code> / <code>updated</code> events will fire. In both cases, the <code>saving</code> / <code>saved</code> events will fire.</p>

<h4 id="cancelling-save-operations-via-events">Cancelling Save Operations Via Events</h4>

<p>If <code>false</code> is returned from the <code>creating</code>, <code>updating</code>, <code>saving</code>, or <code>deleting</code> events, the action will be cancelled:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">User::creating(function($user)
{
    if ( ! $user-&gt;isValid()) return false;
});
</code></pre></div>
<h4 id="where-to-register-event-listeners">Where To Register Event Listeners</h4>

<p>Your <code>EventServiceProvider</code> serves as a convenient place to register your model event bindings. For example:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/**
 * Register any other events for your application.
 *
 * @param  \Illuminate\Contracts\Events\Dispatcher  $events
 * @return void
 */
public function boot(DispatcherContract $events)
{
    parent::boot($events);

    User::creating(function($user)
    {
        //
    });
}
</code></pre></div>
<p><a name="model-observers"></a></p>

<h2 id="model-observers">Model Observers</h2>

<p>To consolidate the handling of model events, you may register a model observer. An observer class may have methods that correspond to the various model events. For example, <code>creating</code>, <code>updating</code>, <code>saving</code> methods may be on an observer, in addition to any other model event name.</p>

<p>So, for example, a model observer might look like this:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class UserObserver {

    public function saving($model)
    {
        //
    }

    public function saved($model)
    {
        //
    }

}
</code></pre></div>
<p>You may register an observer instance using the <code>observe</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">User::observe(new UserObserver);
</code></pre></div>
<p><a name="model-url-generation"></a></p>

<h2 id="model-url-generation">Model URL Generation</h2>

<p>When you pass a model to the <code>route</code> or <code>action</code> methods, it&#39;s primary key is inserted into the generated URI. For example:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Route::get(&#39;user/{user}&#39;, &#39;UserController@show&#39;);

action(&#39;UserController@show&#39;, [$user]);
</code></pre></div>
<p>In this example the <code>$user-&gt;id</code> property will be inserted into the <code>{user}</code> place-holder of the generated URL. However, if you would like to use another property instead of the ID, you may override the <code>getRouteKey</code> method on your model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public function getRouteKey()
{
    return $this-&gt;slug;
}
</code></pre></div>
<p><a name="converting-to-arrays-or-json"></a></p>

<h2 id="converting-to-arrays-/-json">Converting To Arrays / JSON</h2>

<h4 id="converting-a-model-to-an-array">Converting A Model To An Array</h4>

<p>When building JSON APIs, you may often need to convert your models and relationships to arrays or JSON. So, Eloquent includes methods for doing so. To convert a model and its loaded relationship to an array, you may use the <code>toArray</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$user = User::with(&#39;roles&#39;)-&gt;first();

return $user-&gt;toArray();
</code></pre></div>
<p>Note that entire collections of models may also be converted to arrays:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">return User::all()-&gt;toArray();
</code></pre></div>
<h4 id="converting-a-model-to-json">Converting A Model To JSON</h4>

<p>To convert a model to JSON, you may use the <code>toJson</code> method:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">return User::find(1)-&gt;toJson();
</code></pre></div>
<h4 id="returning-a-model-from-a-route">Returning A Model From A Route</h4>

<p>Note that when a model or collection is cast to a string, it will be converted to JSON, meaning you can return Eloquent objects directly from your application&#39;s routes!</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Route::get(&#39;users&#39;, function()
{
    return User::all();
});
</code></pre></div>
<h4 id="hiding-attributes-from-array-or-json-conversion">Hiding Attributes From Array Or JSON Conversion</h4>

<p>Sometimes you may wish to limit the attributes that are included in your model&#39;s array or JSON form, such as passwords. To do so, add a <code>hidden</code> property definition to your model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class User extends Model {

    protected $hidden = [&#39;password&#39;];

}
</code></pre></div>
<blockquote>
<p><strong>Note:</strong> When hiding relationships, use the relationship&#39;s <strong>method</strong> name, not the dynamic accessor name.</p>
</blockquote>

<p>Alternatively, you may use the <code>visible</code> property to define a white-list:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">protected $visible = [&#39;first_name&#39;, &#39;last_name&#39;];
</code></pre></div>
<p><a name="array-appends"></a>
Occasionally, you may need to add array attributes that do not have a corresponding column in your database. To do so, simply define an accessor for the value:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public function getIsAdminAttribute()
{
    return $this-&gt;attributes[&#39;admin&#39;] == &#39;yes&#39;;
}
</code></pre></div>
<p>Once you have created the accessor, just add the value to the <code>appends</code> property on the model:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">protected $appends = [&#39;is_admin&#39;];
</code></pre></div>
<p>Once the attribute has been added to the <code>appends</code> list, it will be included in both the model&#39;s array and JSON forms. Attributes in the <code>appends</code> array respect the <code>visible</code> and <code>hidden</code> configuration on the model.</p>

      </article>

    
        </div>
    </div>
</div>
<script>
$('p a[name]').each(function(){
  var name = $(this).attr('name');
  $(this).parent().next('h2').wrapInner('<a name=' + name + '></a>');
  $(this).parent().remove();
});
$('code[class=language-text]').each(function(){
	$(this).removeClass('language-text').addClass('language-php');
});
</script>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
  var pageTracker = _gat._getTracker("UA-46389165-7");
pageTracker._trackPageview();
} catch(err) {}
</script>

  </body>

</html>
